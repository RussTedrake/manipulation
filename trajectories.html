<!DOCTYPE html>

<html>

  <head>
    <title>Ch. 7 - Motion Planning</title>
    <meta name="Ch. 7 - Motion Planning" content="text/html; charset=utf-8;" />
    <link rel="canonical" href="http://manipulation.csail.mit.edu/trajectories.html" />

    <script src="https://hypothes.is/embed.js" async></script>
    <script type="text/javascript" src="chapters.js"></script>
    <script type="text/javascript" src="htmlbook/book.js"></script>

    <script src="htmlbook/mathjax-config.js" defer></script> 
    <script type="text/javascript" id="MathJax-script" defer
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
    <script>window.MathJax || document.write('<script type="text/javascript" src="htmlbook/MathJax/es5/tex-chtml.js" defer><\/script>')</script>

    <link rel="stylesheet" href="htmlbook/highlight/styles/default.css">
    <script src="htmlbook/highlight/highlight.pack.js"></script> <!-- http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html#language-names-and-aliases -->
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" type="text/css" href="htmlbook/book.css" />
  </head>

<body onload="loadChapter('manipulation');">

<div data-type="titlepage" pdf="no">
  <header>
    <h1><a href="index.html" style="text-decoration:none;">Robotic Manipulation</a></h1>
    <p data-type="subtitle">Perception, Planning, and Control</p> 
    <p style="font-size: 18px;"><a href="http://people.csail.mit.edu/russt/">Russ Tedrake</a></p>
    <p style="font-size: 14px; text-align: right;"> 
      &copy; Russ Tedrake, 2020-2022<br/>
      Last modified <span id="last_modified"></span>.</br>
      <script>
      var d = new Date(document.lastModified);
      document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
      <a href="misc.html">How to cite these notes, use annotations, and give feedback.</a><br/>
    </p>
  </header>
</div>

<p pdf="no"><b>Note:</b> These are working notes used for <a
href="http://manipulation.csail.mit.edu/Fall2022/">a course being taught
at MIT</a>. They will be updated throughout the Fall 2022 semester.  <!-- <a 
href="https://www.youtube.com/channel/UChfUOAhz7ynELF-s_1LPpWg">Lecture  videos are available on YouTube</a>.--></p> 

<table style="width:100%;" pdf="no"><tr style="width:100%">
  <td style="width:33%;text-align:left;"><a class="previous_chapter" href=mobile.html>Previous Chapter</a></td>
  <td style="width:33%;text-align:center;"><a href=index.html>Table of contents</a></td>
  <td style="width:33%;text-align:right;"><a class="next_chapter" href=force.html>Next Chapter</a></td>
</tr></table>

<script type="text/javascript">document.write(notebook_header('trajectories'))
</script>
<!-- EVERYTHING ABOVE THIS LINE IS OVERWRITTEN BY THE INSTALL SCRIPT -->
<chapter style="counter-reset: chapter 6"><h1>Motion Planning</h1>

  <p>There are a few more essential skills that we need in our toolbox.  In this
  chapter, we will explore some of the powerful methods of kinematic trajectory
  motion planning.</p>

  <div>I'm actually almost proud of making it this far into the notes without
  covering this topic yet.  Writing a relatively simple script for the pose of
  the gripper, like we did in the bin picking chapter, really can solve a lot of
  interesting problems.  But there are a number of reasons that we might want a
  more automated solution:
  <ol><li>When the environment becomes more cluttered, it is harder to write
  such a simple solution, and we might have to worry about collisions between
  the arm and the environment as well as the gripper and the environment.</li>
  <li>If we are doing "mobile manipulation" -- our robotic arms are attached to
  a mobile base -- then the robot might have to operate in many different environments.  Even if the workspace is not geometrically complicated,
  it might still be different enough each time we reach that it requires
  automated (but possibly still simple) planning.</li><li>If the robot is
  operating in a simple known environment all day long, then it probably makes
  sense to optimize the trajectories that it is executing; we can often speed up
  the manipulation process significantly.</li>
  </div>

  <p>In fact, if you ran the <a href="clutter.html#clutter_clearing">clutter
  clearing demo</a>, I would say that motion planning failures were the biggest
  limitation of that solution so far: the hand or objects could sometimes
  collide with the cameras or bins, or the differential-inverse kinematics
  strategy (which effectively ignored the joint angles) would sometime cause the
  robot to fold in on itself. In this chapter we'll develop the tools to
  make that much better!</p>

  <p>I do need to make one important caveat. For motion planning in
  manipulation, lots of emphasis is placed on the problem of avoiding
  collisions. Despite having done some work in this field myself, I actually
  really dislike the problem formulation of collision-free motion planning.  I
  think that on the whole, robots are too afraid of bumping into the world
  (because things still go wrong when they do). I don't think humans are
  solving these complex geometric problems every time we reach... even when we
  are reaching in dense clutter. I actually suspect that we are very bad at
  solving them. I would much rather see robots that perform well even with very
  coarse / approximate plans for moving through a cluttered environment, that
  are not afraid to make incidental contacts, and that can still accomplish the
  task when they do!</p>

  <section><h1>Inverse Kinematics</h1>

    <p>The goal of this chapter is to solve for motion trajectories.  But I would argue that if you really understand how to solve inverse kinematics, then you've got most of what you need to plan trajectories.</p>

    <p>We know that the <a href="pick.html#kinematics">forward kinematics</a>
    give us a (nonlinear) mapping from joint angles to e.g. the pose of the
    gripper: $X^G = f_{kin}(q)$.  So, naturally, one would think that the
    problem of inverse kinematics (IK) is about solving for the inverse map, $q
    = f^{-1}_{kin}(X^G).$  But, like we did with differential inverse
    kinematics, I'd like to think about inverse kinematics as the more general
    problem of finding joint angles subject to a rich library of costs and
    constraints; and the space of possible kinematic constraints is indeed
    rich.</p>

    <p>For example, when we were <a
    href="clutter.html#grasp_candidates">evaluating grasp candidates for bin
    picking</a>, we had only a soft preference on the orientation of the hand
    relative to some antipodal grasp.  In that case, specifying 6 DOF pose of
    the gripper and finding one set of joint angles which satisfies it exactly
    would have been an overly constrained specification.  I would say that it's
    rare that we have only end-effector pose constraints to reason about, we
    almost always have costs or constraints in joint space (like joint limits)
    and others in Cartesian space (like non-penetration constraints).</p>

    <figure>
      <iframe width="560" height="315" src="https://www.youtube.com/embed/m1rv4d_zUCY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen pdf="no"></iframe>
      <p pdf="only"><a href="https://www.youtube.com/embed/m1rv4d_zUCY">Click here to watch the video.</a></p>
      <figcaption>We made extensive use of rich inverse kinematics
      specifications in our work on humanoid robots.  The video above is an
      example of the interactive inverse kinematics interface (here to help us
      figure out how to fit the our big humanoid robot into the little Polaris).
      <a href="https://www.youtube.com/watch?v=E_CVq0lWfSc">Here is another
      video</a> of the same tool being used for the Valkyrie humanoid, where we
      do specify and end-effector pose, but we also add a joint-centering
      objective and static stability constraints <elib>Fallon14+Marion16</elib>.
      </figcaption>
    </figure>
  
    <subsection><h1>From end-effector pose to joint angles</h1>

      <p>With its obvious importance in robotics, you probably won't be
      surprised to hear that there is an extensive literature on inverse
      kinematics.  But you may be surprised at how extensive and complete the
      solutions can get. The forward kinematics, $f_{kin}$, is a nonlinear
      function in general, but it is a very structured one.  In fact, with rare
      exceptions (like if your robot has a <a
      href="https://www.hindawi.com/journals/mpe/2016/1761968/fig4/">helical
      joint</a>, aka screw joint), the equations governing the valid Cartesian
      positions of our robots are actually <i>polynomial</i>.  "But wait!  What
      about all of those sines and cosines in my kinematic equations?" you say.
      The trigonometric terms come when we want to relate joint angles with
      Cartesian coordinates.  In $\Re^3$, for two points, $A$ and $B$, on the
      same rigid body, the (squared) distance between them, $\|p^A - p^B\|^2,$
      is a constant.  And a joint is just a polynomial constraint between
      positions on adjoining bodies, e.g. that they occupy the same point in
      Cartesian space.  See <elib>Wampler11</elib> for an excellent
      overview.</p>

      <todo>example: trig and polynomial kinematics of a two-link arm.</todo>

      <p>Understanding the solutions to polynomial equations is the subject of
      algebraic geometry.  There is a deep literature on kinematics theory, on
      symbolic algorithms, and on numerical algorithms.  For even very complex
      kinematic topologies, such as <a
      href="https://en.wikipedia.org/wiki/Four-bar_linkage">four-bar
      linkages</a> and <a
      href="https://en.wikipedia.org/wiki/Stewart_platform">Stewart-Gough
      platforms</a>, we can count the number of solutions, and/or understand
      the continuous manifold of solutions.  For instance,
      <elib>Wampler11</elib>
      describes a substantial toolbox for numerical algebraic geometry (based on
      homotopy methods) with impressive results on difficult kinematics
      problems.</p>

      <p>While the algebraic-geometry methods are mostly targeted for offline
      global analysis, they are not designed for fast real-time inverse
      kinematics solutions needed in a control loop.  The most popular tool
      these days for real-time inverse kinematics for six- or seven-DOF
      manipulators is a tool called "IKFast", described in Section 4.1
      of <elib>Diankov10</elib>, that gained popularity because of its effective
      open-source implementation.  Rather than focus on completeness, IKFast
      uses a number of approximations to provide fast and numerically robust
      solutions to the "easy" kinematics problems.  It leverages the fact that a
      six-DOF pose constraint on a six-DOF manipulator has a "closed-form"
      solution with a finite number of joint space configurations that produce
      the same end-effector pose, and for seven-DOF manipulators it adds a layer
      of sampling in the last degree of freedom on top of the six-DOF
      solver.</p>

      <todo>add an example of calling (or implementing something equivalent to)
      IKFast and/or Bertini. looks like bertini 2 has python bindings (but not
      pip) and is GPL3.</todo>

      <p>These explicit solutions are important to understand because they
      provide deep insight into the equations, and because they can be fast
      enough to use inside a more sophisticated solution approach.  But the
      solutions don't provide the rich specification I advocated for above; in
      particular, they break down once we have inequality constraints instead
      of equality constraints.  For those richer specifications, we will turn
      to optimization.</p>

    </subsection>

    <subsection><h1>IK as constrained optimization</h1>

      <p>Rather than formulate inverse kinematics as $$q = f^{-1}_{kin}(X^G),$$
      let's consider solving the same problem as an optimization: \begin{align}
      \min_q & \quad |q - q_0|^2, \\ \subjto &\quad X^G = f_{kin}(q),
      \end{align} where $q_0$ is some comfortable nominal position. While
      writing the inverse directly is a bit problematic, especially because we
      sometimes have multiple (even infinite) solutions or no solutions. This
      optimization formulation is slightly more precise -- if we have multiple
      joint angles which achieve the same end-effector position, then we prefer
      the one that is closest to the nominal joint positions. But the real
      value of switching to the optimization perspective of the problem is that
      it allows us to connect to a rich library of additional costs and
      constraints.</p>

      <figure><img style="width:60%" src="data/shelf_ik.png"><figcaption>A
      richer inverse kinematics problem: solve for the joint angles, $q$, that
      allow the robot to reach into the shelf and grab the object, while
      avoiding collisions.</figcaption></figure>

      <p>We have <a href="pick.html#diff_ik_w_constraints">already
      discussed</a> the idea of solving <i>differential</i> inverse kinematics
      as an optimization problem.  In that workflow, we started by using the
      pseudo-inverse of the kinematic Jacobian, but then graduated to thinking
      about the least-squares formulation of the inverse problem.  The more
      general least-squares setting, we could add additional costs and
      constraints that would protect us from (nearly) singular Jacobians and
      could take into account additional constraints from joint limits, joint
      velocity limits, etc.  We could even add collision avoidance constraints.
      Some of these constraints are quite nonlinear / nonconvex functions of
      the configuration $q$, but in the differential kinematics setting we were
      only seeking to find a small change $\Delta q$ around the nominal
      configuration, so it was quite reasonable to make linear/convex
      approximations of these nonlinear/nonconvex constraints.
      </p>

      <p>Now we will consider the full formulation, where we try to solve the
      nonlinear / nonconvex optimization directly, without any constraints on
      only making a small change to an initial $q$.  This is a much harder
      problem computationally.  Using powerful nonlinear optimization solvers
      like SNOPT, we are often able to solve the problems, even at interactive
      rates (the example below is quite fun).  But there are no guarantees.  It
      could be that a solution exists even if the solver returns
      "infeasible".</p>

      <p>Of course, the differential IK problem and the full IK problem are
      closely related.  In fact, you can think about the differential IK
      algorithm as doing one step of (projected) gradient descent or  one-step
      of <a
      href="https://en.wikipedia.org/wiki/Sequential_quadratic_programming">Sequential Quadratic Programming</a>,
      for the full nonlinear problem.</p>

      <p>Drake provides a nice <a
      href="https://drake.mit.edu/doxygen_cxx/classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a>
      class that makes it easy to assemble many of the standard
      kinematic/multibody constraints into a
      <code>MathematicalProgram</code>.  Take a minute to look at the
      constraints that are offered.  You can add constraints on the relative
      position and/or orientation on two bodies, or that two bodies are more
      than some minimal distance apart (e.g. for non-penetration) or closer
      than some distance, and more.  This is the way that I want you to think
      about the IK problem; it is an inverse problem, but one with a
      potentially very rich set of costs and constraints.</p>

      <example><h1>Interactive IK</h1>

        <p>Despite the nonconvexity of the problem and nontrivial computational
        cost of evaluating the constraints, we can often solve it at
        interactive rates.  I've assembled a few examples of this in the
        chapter notebook:</p>

        <script>document.write(notebook_link('trajectories', d=deepnote, link_text="", notebook="interactive_ik"))</script>

        <p>In the first version, I've added sliders to let you control the
        desired pose of the end-effector.  This is the simple version of the IK
        problem, amenable to more explicit solutions, but we nevertheless solve
        it with our full nonlinear optimization IK engine (and it does include
        joint limit constraints).  This demo won't look too different from the
        very first example in the notes, where you used teleop to command the
        robot to pick up the red brick.  In fact, differential IK offers a fine
        solution to this problem, too.</p>

        <p>In the second example, I've tried to highlight the differences
        between the nonlinear IK problem and the differential IK problem by
        adding an obstacle directly in front of the robot.  Because both our
        differential IK and IK formulations are able to consume the
        collision-avoidance constraints, both solutions will try to prevent you
        from crashing the arm into the post.  But if you move the target
        end-effector position from one side of the post to the other, the full
        IK solver can switch over to a new solution with the arm on the other
        side of the post, but the differential IK will never be able to make
        that leap (it will stay on the first side of the post, refusing to
        allow a collision).</p>

        <figure>
            <img width="40%" src="data/ik_post_1.png"/>
            <img width="40%" src="data/ik_post_2.png"/>
            <figcaption>As the desired end-effector position moves along
            positive $y$, the IK solver is able to find a new solution with the
            arm wrapped the other way around the post.</figcaption>
        </figure>


      </example>

      <p>With great power comes great responsibility.  The inverse kinematics
      toolbox allows you to formulate complex optimizations, but your success
      with solving them will depend partially on how thoughtful you are about
      choosing your costs and constraints.  My basic advice is this: <ol>
      <li>Try to keep the objective (costs) simple; I typically only use the
      "joint-centering" quadratic cost on $q$.  Putting terms that should be
      constraints into the cost as penalties leads to lots of cost-function
      tuning, which can be a nasty business.</li><li>Write minimal constraints.
      You want the set of feasible configurations to be as big as possible.
      For instance, if you don't need to fully constrain the orientation of the
      gripper, then don't do it.</li></ol>  I'll follow-up with that second
      point using the following example.</p>

      <example><h1>Grasp the cylinder</h1>
      
        <p>Let's use IK to grasp a cylinder (call it a hand rail).  Suppose it
        doesn't matter where along the cylinder we grasp, nor the orientation
        at which we grasp it.  Then we should write the IK problem using
        only the minimal version of those constraints.</p>

        <p>In the notebook, I've coded up one version of this.  I've put the
        cylinder's pose on the sliders now, so you can move it around the
        workspace, and watch how the IK solver decides to position the robot.
        In particular, if you move the cylinder in $\pm y$, you'll see that the
        robot doesn't try to follow... until the hand gets to the end of the
        cylinder.  Very nice!</p>

        <figure>
            <img width="30%" src="data/grasp_cylinder_1.png"/>
            <img width="30%" src="data/grasp_cylinder_2.png"/>
            <img width="30%" src="data/grasp_cylinder_3.png"/>
        </figure>

        <p>One could imagine multiple ways to implement that constraint.
        Here's how I did it: 

<pre><code class="language-python">ik.AddPositionConstraint(
    frameB=gripper_frame, p_BQ=[0, 0.1, -0.02],
    frameA=cylinder_frame, p_AQ_lower=[0, 0, -0.5], p_AQ_upper=[0, 0, 0.5])
ik.AddPositionConstraint(
    frameB=gripper_frame, p_BQ=[0, 0.1, 0.02], 
    frameA=cylinder_frame, p_AQ_lower=[0, 0, -0.5], p_AQ_upper=[0, 0, 0.5])</code></pre>  
    
        In words, I've defined two points in the gripper frame; in the notation
        of the <code>AddPositionConstraint</code> method they are ${}^Bp^{Q}$.
        Recall the <a href="pick.html#grasp_frames">gripper frame</a> is such
        that $[0, .1, 0]$ is right between the two gripper pads; you should
        take a moment to make sure you understand where $[0,.1,-0.02]$ and
        $[0,.1,0.02]$ are.  Our constraints require that both of those points
        should lie exactly on the center line segment of the cylinder.  This
        was a compact way for me to leave the orientation around the cylinder
        axis as unconstrained, and capture the cylinder position constraints
        all quite nicely.</p>

        <script>document.write(notebook_link('trajectories', d=deepnote, link_text="", notebook="interactive_ik"))</script>

      </example>

      <p>We've provided a rich language of constraints for specifying IK
      problems, including many which involve the kinematics of the robot and
      the geometry of the robot and the world (e.g., the minimum-distance
      constraints).  Let's take a moment to appreciate the geometric puzzle
      that we are asking the optimizer to solve.</p>

      <example><h1>Visualizing the configuration space</h1>

        <p>Let's return to the example of the iiwa reaching into the shelf.
        This IK problem has two major constraints: 1) we want the center of the
        target sphere to be in the center of the gripper, and 2) we want the
        arm to avoid collisions with the shelves.  In order to plot these
        constraints, I've frozen three of the joints on the iiwa, leaving only
        the three corresponding motion in the $x-z$ plane.</p>

        <figure>
            <img width="40%" src="data/shelf_ik2.png"/>
            <img width="40%" src="data/shelf_ik_cspace_grasp_constraint.png"/>
            <figcaption>The image on the right is a visualization of the "grasp
            the sphere" constraint in configuration space -- the x,y,z, axes in
            the visualizer correspond to the three joint angles of the
            planarized iiwa.</figcaption>
        </figure>

        <p>To visualize the constraints, I've sampled a dense grid in the three
        joint angles of the planarized iiwa, assigning each grid element to 1
        if the constraint is satisfied or 0 otherwise, then run a marching
        cubes algorithm to extract an approximation of the true 3D geometry of
        this constraint in the configuration space.  The "grasp the sphere"
        constraint produces the nice green geometry I've pictured above on the
        right; it is clipped by the joint limits.  The collision-avoidance
        constraint, on the other hand, is quite a bit more complicated.  To see
        that, you'd better open up this
        <a href="data/iiwa_shelves_configuration_space.html">3D
        visualization</a> so you can navigate around it yourself.  Scary!</p>

        <script>document.write(notebook_link('trajectories', d=deepnote, link_text="", notebook="cspace"))</script>

      </example>

      <example><h1>Visualizing the IK optimization problem</h1>
      
        <p>To help you appreciate the problem that we've formulated, I've made
        a visualization of the optimization landscape. Take a look at the
        landscape <a href="data/shelf_ik_prog_zoom.html">here</a> first; this
        is only plotting a small region around the returned solution. You can
        use the Meshcat controls to show/hide each of the individual costs and
        constraints, to make sure you understand.</p>
        
        <p>As recommended, I've kept the cost landscape (the <i>green</i>
        surface) to be simply the quadratic joint-centering cost. The
        constraints are plotted in <i>blue</i> when they are feasible, and
        <i>red</i> when they are infeasible:
        <ul>
          <li>The joint limit constraint is just a simple "bounding-box"
          constraint here (only the red infeasible region is drawn for bounding
          box constraints, to avoid making the visualization too
          cluttered).</li>
          <li>The position constraint has three elements: for the $x$, $y$, and
          $z$ positions of the end-effector. The $y$ position constraint is
          trivially satisfied (all blue) because the manipulator only has the
          joints that move in the $x-z$ plane. The other two look all red, but
          if you turn off the $y$ visualization, you can see two small strips
          of blue in each. That's the conditions in our tight position
          constraint.</li>
          <li>But it's the "minimum-distance" (non-collision) constraint that is the most impressive / scary of all. While we visualized the configuration space above, you can see here that visualizing the distance as a real-valued function reveals the optimization landscape that we give to the solver.</li>
        </ul> The intersection of all the blue regions here are what defined
        the configuration-space in the example above. All of the code for this
        visualization is available in the notebook, and you can find the exact
        formulation of the costs and constraints there:</p>  

        <script>document.write(notebook_link('trajectories', d=deepnote, link_text="", notebook="optimization_landscape"))</script>
        
        <p>You should also take a quick look at the <a
        href="data/shelf_ik_prog.html">full optimization landscape</a>.  This
        is the same set of curves as in the visualization above, but now it's
        plotted over the entire domain of joint angles within the joint limits.
        Nonlinear optimizers like SNOPT can be pretty amazing sometimes!</p>

      </example>

    </subsection>
    
    <subsection><h1>Global inverse kinematics</h1>      

      <p>For unconstrained inverse kinematics with exactly six degrees of
      freedom, we have closed-form solutions. For the generalized inverse
      kinematics problem with rich costs and constraints, we've got a nonlinear
      optimization problem that works well in practice but is subject to local
      minima (and therefore can fail to find a feasible solution if it exists).
      If we give up on solving the optimization problem at interactive rates,
      is there any hope of solving the richer IK formulation robustly?  Ideally
      to global optimality?</p>

      <p>This is actually and extremely relevant question. There are many
      applications of inverse kinematics that work offline and don't have any
      strict timing requirements. Imagine if you wanted to generate training
      data to train a neural network to learn your inverse kinematics; this
      would be a perfect application for global IK. Or if you want to do
      workspace analysis to see if the robot can reach all of the places it
      needs to reach in the workspace that you're designing for it, then you'd
      like to use global IK. Some of the motion planning strategies that we'll
      study below will also separate their computation into an offline
      "building" phase to make the online "query" phase much faster.</p>

      <p>In my experience, general-purpose global nonlinear solvers -- for
      instance, based on mixed-integer nonlinear programming (MINLP) approaches
      or the interval arithmetic used in <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">satisfiability-modulo-theories (SMT)</a>
      solvers -- typically don't scale the complexity of a full manipulator.
      But if we only slightly restrict the class of costs and constraints that
      we support, then we can begin to make progress.
      </p>

      <p>Drake provide an implementation of the <a
      href="https://drake.mit.edu/doxygen_cxx/classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a>
      approach described in <elib>Dai17</elib> using mixed-integer convex
      optimization. The solution times are on the order of a few seconds; it
      can solve a full constrained bimanual problem in well under a minute.
      <elib>Trutman22</elib> solves the narrow version of the problem (just
      end-effector poses and joint limits) using convex optimization via a
      hierarchy of semi-definite programming relaxations; it would be very
      interesting to understand how well this approach works the larger family
      of costs and constraints.</p>

    </subsection>

    <subsection>
      <h1>Inverse kinematics vs differential inverse kinematics</h1>

      <p>When should we use IK vs Differential IK?  IK solves a more global
      problem, but is not guaranteed to succeed.  It is also not guaranteed to
      make small changes to $q$ as you make small changes in the
      cost/constraints; so you might end up sending large $\Delta q$ commands
      to your robot.  Use IK when you need to solve the more global problem,
      and the trajectory optimization algorithms we produce in the next section
      are the natural extension to producing actual $q$ trajectories.
      Differential IK works extremely well for incremental motions -- for
      instance if you are able to design smooth commands in end-effector space
      and simply track them in joint space.</p>

    </subsection>

    <subsection><h1>Grasp planning using inverse kinematics</h1>
    
      <p>In our first version of <a href="clutter.html#grasp_sampling">grasp
      selection</a> using sampling, we put an objective that rewarded grasps
      that were oriented with the hand grasping from above the object. This was
      a (sometimes poor) surrogate for the problem that we really wanted to
      solve: we want the grasp to be achievable given a "comfortable" position
      of the robot. So a simple and natural extension of our grasp scoring
      metric would be to solve an inverse kinematics problem for the grasp
      candidate, and instead of putting costs on the end-effector orientation,
      we can use the joint-centering cost directly as our objective.
      Furthermore, if the IK problem returns infeasible, we should reject the
      sample.</p>

      <p>There is a quite nice extension of this idea that becomes quite
      natural once we take the optimization view, and it is a nice transition
      to the trajectory planning we'll do in the next section.  Imagine if the
      task requires us not only to pick up the object in clutter, but also to
      place the object carefully in clutter as well. In this case, a good grasp
      is finds a pose for the hand relative to the object that
      <i>simultaneously optimizes</i> both the pick configuration and the place
      configuration. This is actually quite natural to do with inverse
      kinematics; one can formulate an optimization problem with decision
      variables for both $q_{pick}$ and $q_{place}$, with constraints enforcing
      that ${}^OX^{G_{pick}} = {}^OX^{G_{place}}$.</p> 
      
      <todo>Simple code example here</todo>

      <p>Once we add in all of our other rich costs and constraints, this
      becomes a quite sophisticated approach. In the <a
      href="pose.html#tri_dishloading">dish-loading project at TRI</a>, this
      approach proved to be very important. Both picking up a mug in the sink
      and placing it in the dishwasher rack are highly constrained, so we
      needed the simultaneous optimization to find successful grasps.</p>

    </subsection>

  </section>

  <!-- maybe section on collision detection / constraints? GJK? octrees? -->

  <section><h1>Kinematic trajectory optimization</h1>
  
    <p>Once you understand the optimization perspective of inverse kinematics,
    then you are well on your way to understanding kinematic trajectory
    optimization. Rather than solving multiple inverse kinematics problems
    independently, the basic idea now is to solve for a sequence of joint
    angles in the same optimization. Even better, let us define a parameterized
    joint trajectory, $q_\alpha(t)$, where $\alpha$ are parameters. Then a
    simple extension to our inverse kinematics problem would be to write
    something like \begin{align} \min_{\alpha,T} & \quad T, \\ \subjto &\quad
    X^{G_{start}} = f_{kin}(q_\alpha(0)),\\ & \quad X^{G_{goal}} =
    f_{kin}(q_\alpha(T)), \\ & \quad \forall t , \quad
    \left|\dot{q}_\alpha(t)\right| \le v_{max} \label{eq:vel_limits}.
    \end{align} I read this as "find a trajectory, $q(t)$ for $t \in [0, T]$,
    that moves the gripper from the start to the goal in minimum time".</p>
    
    <p>The last equation, (\ref{eq:vel_limits}), represents velocity limits;
    this is the only way we are telling the optimizer that the robot cannot
    teleport instantaneously from the start to the goal. Apart from this line
    which looks a little non-standard, it is almost exactly like solving two
    inverse kinematics problems jointly, except instead of having the solver
    take gradients with respect to $q$, we will take gradients with respect to
    $\alpha$. This is easily accomplished using the chain rule.</p>

    <subsection><h1>Trajectory parameterizations</h1>
    
      <p>The interesting question, then, becomes how to do we actually
      parameterize the trajectory $q(t)$ with a parameter vector $\alpha$?
      These says, you might think that $q_\alpha(t)$ could be a neural network
      that takes $t$ as an input, offers $q$ as an output, and uses $\alpha$ to
      represent the weights and biases of the network. Of course you could, but
      for inputs with a scalar input like this, we often take much simpler and
      sparser parameterizations, often based on polynomials.</p>

      <p>There are many ways one can parameterize a trajectory with
      polynomials. For example in <i>dynamic</i> motion planning, <a
      href="https://underactuated.csail.mit.edu/trajopt.html#direct_collocation">direct
      collocation methods</a> uses <a
      href="https://drake.mit.edu/doxygen_cxx/classdrake_1_1trajectories_1_1_piecewise_polynomial.html">piecewise-cubic
      polynomials</a> to represent the state trajectory, and the <a
      href="https://underactuated.csail.mit.edu/trajopt.html#pseudo-spectral">pseudo-spectral
      methods</a> use Lagrange polynomials. In each case, the choice of basis
      functions is made so that algorithm can leverage a particular property of
      the basis. In dynamic motion planning, a great deal of focus is on the integration accuracy of the dynamic equations to ensure that we obtain feasible solutions to the dynamic constraints..</p>

      <p>When we are planning the motions of our fully-actuated robot arms, we
      typically worry less about dynamic feasibility, and focus instead on the
      kinematics. For <i>kinematic</i> trajectory optimization, the so-called
      <a
      href="https://drake.mit.edu/doxygen_cxx/classdrake_1_1trajectories_1_1_bspline_trajectory.html">B-spline
      trajectory</a> parameterization has a few particularly nice properties
      that we can leverage here:
      <ul><li>The derivative of a B-spline is still a B-spline (of one less
      degree), with coefficients that are linear in the original
      coefficients.</li><li>The bases themselves are non-negative and sparse.
      This gives the coefficients of the B-spline polynomial, which are
      referred to as the <i>control points</i>, a strong geometric
      interpretation.</li>
      <li>In particular, the entire trajectory is guaranteed to lie inside the
      convex hull of the active control points (the control points who's bases
      are not zero).</li></ul>
      Taken together this means that we can optimize over finitely
      parameterized trajectories, but use the convex hull property to ensure
      that limits on the joint positions and any of its derivatives are
      satisfied $\forall t\in [0,T]$ using <i>linear</i> constraints.  This
      sort of guarantee is much more costly to obtain using most other
      polynomial bases.</p>
      
      <todo>Write up the B-spline math here; and clean up the Drake
      notation/implementation in the process. In particular, I want to purse
      the use of symbolic from KinematicTrajectoryOptimization. My
      `RussTedrake/drake:bsplinebasis_derivatives` branch has a start at
      getting analytical derivatives for the trajopt workflow. </todo>

      <p>Note that <a
      href="https://en.wikipedia.org/wiki/B-spline">B-splines</a> are closely
      related to <a
      href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">B&eacute;zier
      curves</a>. But the "B" in "B-spline" actually just stands for "basis"
      (no, I'm not kidding) and "<a
      href="https://en.wikipedia.org/wiki/Composite_B%C3%A9zier_curve">B&eacute;zier-splines</a>"
      are slightly different.
      </p>
      
      <todo>A simple interactive gui for moving around the control points and visualizing the spline.</todo>

    </subsection>

    <subsection><h1>Optimization algorithms</h1>

      <p>The default <a
      href="https://drake.mit.edu/doxygen_cxx/classdrake_1_1planning_1_1trajectory__optimization_1_1_kinematic_trajectory_optimization.html"><code>KinematicTrajectoryOptimization</code></a>
      class in Drake optimizes a trajectory defined using a B-spline to
      represent a path, $r(s)$ over the interval $s \in [0,1]$, plus an
      additional scalar decision variable corresponding to the trajectory
      duration, $T$. The final trajectory combines the path with the
      time-rescaling: $q(t) = r(t/T).$ This is a particularly nice way to
      represent a trajectory of unknown duration, and has the excellent feature
      that the convex hull property can still be used. Velocity constraints are
      still linear; constraints on acceleration and higher derivatives do
      become nonlinear, but if satisfied they still imply strict bounds
      $\forall t \in [0, T].$</p>

      <p>Since the <code>KinematicTrajectoryOptimization</code> is written
      using Drake's <code>MathematicalProgram</code>, by default it will
      automatically select what we think is the best solver given the available
      solvers. If the optimization has only convex costs and constraints, it
      will be dispatched to a convex optimization solver. But most often we add
      in nonconvex <a
      href="https://drake.mit.edu/doxygen_cxx/group__solver__evaluators.html">costs
      and constraints from kinematics</a>. Therefore in most cases, the default
      solver would again be the SQP-solver, SNOPT. You are free to experiment
      with others!</p>

      <p>One of the most interesting set of constraints that we can add to our
      kinematic trajectory optimization problem is the <a
      href="https://drake.mit.edu/doxygen_cxx/classdrake_1_1multibody_1_1_minimum_distance_constraint.html">MinimumDistanceConstraint</a>;
      when the minimum distance between all potential collision pairs is
      greater than zero then we have avoided collisions. Please note, though,
      that these collision constraints can only be enforced at discrete
      samples, $s_i \in [0,1]$, along the path. <i>They do not guarantee that
      the trajectory is collision free $\forall t\in[0,T].$</i> It required
      very special properties of the derivative constraints to leverage the
      convex hull property; we do not have them for more general nonlinear
      constraints. A common strategy is to add constraints at some modest
      number of samples along the interval during optimization, then to check
      for collisions more densely on the optimized trajectory before executing
      it on the robot.</p>

      <example><h1>Kinematic trajectory optimization for moving between shelves</h1>
      
        <p>As a warm-up, I've provided a simple example of the planar iiwa
        reaching from the top shelf into the middle shelf.</p>

        <script>document.write(notebook_link('trajectories', d=deepnote, link_text="", notebook="kinematic_trajectory_optimization"))</script>
      
        <p>If you look carefully at the code, I actually had to solve this
        trajectory optimization twice to get SNOPT to return a good solution
        (unfortunately, since it is a local optimization, this can happen). For
        this particular problem, the strategy that worked was to solve once
        without the collision avoidance constraint, and then use that
        trajectory as an initial guess for the problem with the collision
        avoidance constraint.</p>

        <p>Another thing to notice in the code is the "visualization callback"
        that I use to plot a little blue line for the trajectory as the
        optimizer is solving. Visualization callbacks are implemented by e.g.
        telling the solver about a cost function that depends on all of the
        variables, and always returns zero cost; they get called every time the
        solver evaluates the cost functions. What I've done here can definitely
        slow down the optimization, but it's an excellent way to get some
        intuition about when the solver is "struggling" to numerically solve a
        problem. I think that the people / papers in this field with the
        fastest and most robust solvers are highly correlated with people who
        spend time visualizing and massaging the numerics of their solvers.</p>

      </example>

      <example><h1>Kinematic trajectory optimization for clutter clearing</h1>
      
        <p>We can use <code>KinematicTrajectoryOptimization</code> to do the
        planning for our clutter clearing example, too. This optimization was
        more robust, and did not require solving twice. I only seeded it with a
        trivial initial trajectory to avoid solutions where the robot tried to
        rotate 270 degrees around its base instead of taking the shorter
        path.</p>

        <script>document.write(notebook_link('trajectories', d=deepnote, link_text="", notebook="kinematic_trajectory_optimization"))</script>
      
      </example>

      <todo>Show example(s) from TRI dish-loading.</todo>

      <p>There are a number of related approaches to kinematic trajectory
      optimization in the motion planning literature, which differ either by
      their parameterization or by the solution technique (or both). Some of
      the more well-known include CHOMP
      <elib>Ratliff09a</elib>, STOMP <elib>Kalakrishnan11a</elib>, and
      KOMO<elib>Toussaint17</elib>.</p>
      
      <p>KOMO, for instance, is one of a wave of trajectory optimization
      techniques that use the <a
      href="https://en.wikipedia.org/wiki/Augmented_Lagrangian_method">Augmented
      Lagrangian method</a> of transcribing a constrained optimization problem
      into an unconstrained problem, then using a simple but fast
      gradient-based solver<elib>Toussaint14</elib>. Augmented-Lagrangian-based
      approaches appear to be the most popular and successful these days; I
      hope to provide a nice implementation in Drake soon!</p>

      <p>When kinematic trajectory optimizations succeed, they are an
      incredibly satisfying solution to the motion planning problem. They give
      a very natural and expressive language for specifying the desired motion
      (with needing to sample nonlinear constraints as perhaps the one
      exception), and they can be solved fast enough for online planning. The
      only problem is: they don't always succeed. Because they are based on
      nonconvex optimization, they are susceptible to local minima, and can
      fail to find a feasible path even when one exists.</p>

      <example><h1>Local minima in collision-free trajectory optimization</h1>
        <p>Consider the extremely simple example of finding the shortest path
        from the start (blue star) to the goal (green star) in the image above,
        avoiding collisions with the red box. Avoiding even the complexity of
        B-splines, we can write an extremely simple optimization of the form:
        \begin{aligned} \min_{q_0, ..., q_N} \quad & \sum_{n=0}^{N-1} | q_{n+1}
        - q_n|_2^2 & \\ \text{subject to} \quad & q_0 = q_{start} \\ & q_N =
        q_{goal} \\ & |q_n|_1 \ge 1 & \forall n, \end{aligned} where the last
        line is the collision-avoidance constraint saying that each sample
        point has to be <i>outside</i> of the $\ell_1$-ball.
        </p>
        
        <figure>
          <img height="200" src="data/redbox_shortest_path.png">
        </figure>
        <todo>Turn that into an animation like the ICP where the initial condition changes</todo>
          
        <p>Once a nonlinear solver is
        considering paths that go right around the obstacle, it is very
        unlikely to find a solution that goes left around the obstacle, because
        the solution would have to get worse (violate the collision constraint)
        before it gets better.</p> 

        <todo>Make a version of this with B-splines</todo>
      </example>

      <p>To deal with this limitation, the field of collision-free motion
      planning has trended heavily towards sampling-based methods.</p>
    </subsection>

  </section>

  <section><h1>Sampling-based motion planning</h1>

    <figure>
      <img height="200" class="invisible_on_hover" src="data/h5chess-static.gif"/>
      <img height="200" src="data/h5chess.gif">

      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 

      <img height="200" class="invisible_on_hover" src="data/h6crouchchair-static.gif"/>
      <img height="200" src="data/h6crouchchair.gif">

      <figcaption>Some incredible early (circa 2002) sampling-based motion planning
      results <a href="http://www.kuffner.org/james/humanoid/planning.php">from
      James Kuffner</a> (hover over the image to animate). These are kinematically complex and quite high dimensional.</figcaption>
    </figure>

    <p>The <a href="https://ompl.kavrakilab.org/">Open Motion Planning
    Library</a>. We have our <a
    href="https://github.com/RobotLocomotion/drake/issues/14431">own
    implementations in Drake</a>
        that are optimized for our collision engines.</p>

    <subsection><h1>Rapidly-exploring random trees (RRT)</h1>
    
      <example><h1>The basic RRT</h1>
    
        <script>document.write(notebook_link('trajectories', d=deepnote, link_text="", notebook="rrt"))</script>
      </example>
    
    </subsection>

    <example><h1>The RRT "Bug Trap"</h1>
    
      <script>document.write(notebook_link('trajectories', d=deepnote, link_text="", notebook="rrt"))</script>
    </example>
    
    </subsection>

    <subsection><h1>The Probabilistic Roadmap (PRM)</h1>
    </subsection>

    <subsection><h1>Post-processing</h1>

      <p><a
      href="https://github.com/RobotLocomotion/drake/issues/11827">anytime
      b-spline smoother</a></p>

    </subsection>

  </section>

  <section><h1>Time-optimal path parameterizations</h1>

    <!-- time-scaling trajectories (TOPPRA?) -->
  </section>

  <section><h1>Graphs of Convex Sets</h1>

  </section>

  <section><h1>Exercises</h1>
    <exercise><h1>Door Opening</h1>
      <p> For this exercise, you will implement a optimization-based inverse kinematics solver to open a cupboard door. You will work exclusively in <script>document.write(notebook_link('door_opening', deepnote['exercises/trajectories'], link_text='this notebook'))</script>. You will be asked to complete the following steps: </p>
      <ol type="a">
        <li> Write down the constraints on the IK problem of grabbing a cupboard handle.
        </li>
        <li> Formalize the IK problem as an instance of optimization. </li>
        <li> Implement the optimization problem using MathematicalProgram.</li>
      </ol>
    </exercise>    

    <exercise id="rrtExercise"><h1>RRT Motion Planning</h1>
      <p> For this exercise, you will implement and analyze the RRT algorithm introduced in class. You will work exclusively in <script>document.write(notebook_link('rrt_planning', deepnote['exercises/trajectories'], link_text='this notebook'))</script>. You will be asked to complete the following steps: </p>
      <ol type="a">
        <li> Implement the RRT algorithm for the Kuka arm.
        </li>
        <li> Answer questions regarding its properties. </li>
      </ol>
    </exercise>    

    <exercise><h1>Improving RRT Path Quality</h1>
      <p>Due to the random process by which nodes are generated, the paths output by RRT can often look somewhat jerky (the "RRT dance" is the favorite dance move of many roboticists). There are many strategies to improve the quality of the paths and in this question we'll explore two. For the sake of this problem, we'll assume path quality refers to path length, i.e. that the goal is to find the shortest possible path, where distance is measured as Euclidean distance in joint space. </p>
      <ol type="a">
        <li> One strategy to improve path quality is to post-process paths via "shortcutting", which tries to replace existing portions of a path with shorter segments <elib>Geraerts04</elib>. This is often implemented with the following algorithm: 1) Randomly select two non-consecutive nodes along the path. 2) Try to connect them with a RRT's extend operator. 3) If the resulting path is better, replace the existing path with the new, better path. Steps 1-3 are repeated until a termination condition (often a finite number of steps or time). For this problem, we can assume that the extend operator is a straight line in joint space. Consider the graph below, where RRT has found a rather jerky path from $q_{start}$ to $q_{goal}$. There is an obstacle (shown in red) and $q_{start}$ and $q_{goal}$ are highlighted in blue (disclaimer: This graph was manually generated to serve as an illustrative example). 

      <figure>
          <img style="width:80%", src="data/shortcutting.png"/>
      </figure>
Name one pair of nodes for which the shortcutting algorithm would result in a shorter path (i.e. two nodes along our current solution path for which we could produce a shorter path if we were to directly connect them). You should assume the distance metric is the 2D Euclidean distance.</li><br/>
        <li> Shortcutting as a post-processing technique, reasons over the existing path and enables local "re-wiring" of the graph. It is a heuristic and does not, however, guarantee that the tree will encode the shortest path. To explore this, let's zoom in one one iteration of RRT (as illustrated below), where $q_{sample}$ is the randomly generated configuration, $q_{near}$ was the closest node on the existing tree and $q_{new}$ is the RRT extension step from $q_{near}$ in the direction of q_sample. When the standard RRT algorithm (which you implemented in <a href="#rrtExercise">a previous exercise</a>) adds $q_{new}$ to the tree, what node is its parent? If we wanted our tree to encode the shortest path from the starting node, $q_{start}$, to each node in the tree, what node should be the parent node of $q_{new}$?</li>
      <figure>
          <img style="width:60%", src="data/rrtstar_step.png"/>
      </figure>
      </ol>
      This idea of dynamically "rewiring" to discover the minimum cost path (which for us is the shortest distance) is a critical aspect of the asymptotically optimal variant of RRT known as RRT* <elib>Karaman11</elib>. As the number of samples tends towards infinity RRT* finds the optimal path to the goal! This is unlike "plain" RRT, which is provably suboptimal (the intuition for this proof is that RRT "traps" itself because it cannot find better paths as it searches). 
    </exercise> 

    <exercise><h1>Decomposing Obstacle-Free Space with Convex Optimization</h1>
      <p> For this exercise, you will implement part of the IRIS algorithm <elib>Deits14</elib>, which is used to compute large regions of obstacle-free space through a series of convex optimizations. These regions can be used by various planning methods that search for trajectories from start to goal while remaining collision-free. You will work exclusively in <script>document.write(notebook_link('taskspace_iris', deepnote['exercises/trajectories'], link_text='this notebook'))</script>. You will be asked to complete the following steps: </p>
      <ol type="a">
        <li> Implement a QP that finds the closest point on an obstacle to an ellipse in free-space. </li>
        <li> Implement the part of the algorithm that searches for a set of hyperplanes that separate a free-space ellipse from all the obstacles. </li>
      </ol>

    </exercise> 

  </section>

</chapter>
<!-- EVERYTHING BELOW THIS LINE IS OVERWRITTEN BY THE INSTALL SCRIPT -->

<div id="references"><section><h1>References</h1>
<ol>

<li id=Fallon14>
<span class="author">Maurice Fallon and Scott Kuindersma and Sisir Karumanchi and Matthew Antone and Toby Schneider and Hongkai Dai and Claudia P\'{e}rez D'Arpino and Robin Deits and Matt DiCicco and Dehann Fourie and Twan Koolen and Pat Marion and Michael Posa and Andr\'{e}s Valenzuela and Kuan-Ting Yu and Julie Shah and Karl Iagnemma and Russ Tedrake and Seth Teller</span>, 
<span class="title">"An Architecture for Online Affordance-based Perception and Whole-body Planning"</span>, 
<span class="publisher">Journal of Field Robotics</span>, vol. 32, no. 2, pp. 229-254, September, <span class="year">2014</span>.
[&nbsp;<a href="http://groups.csail.mit.edu/robotics-center/public_papers/Fallon14.pdf">link</a>&nbsp;]

</li><br>
<li id=Marion16>
<span class="author">Pat Marion and Maurice Fallon and Robin Deits and Andr\'{e}s Valenzuela and Claudia P\'{e}rez D'Arpino and Greg Izatt and Lucas Manuelli and Matt Antone and Hongkai Dai and Twan Koolen and John Carter and Scott Kuindersma and Russ Tedrake</span>, 
<span class="title">"Director: A User Interface Designed for Robot Operation With Shared Autonomy"</span>, 
<span class="publisher">Journal of Field Robotics</span>, vol. 1556-4967, <span class="year">2016</span>.
[&nbsp;<a href="http://groups.csail.mit.edu/robotics-center/public_papers/Marion16.pdf">link</a>&nbsp;]

</li><br>
<li id=Wampler11>
<span class="author">Charles W. Wampler and Andrew J. Sommese</span>, 
<span class="title">"Numerical algebraic geometry and algebraic kinematics"</span>, 
<span class="publisher">Acta Numerica</span>, vol. 20, pp. 469-567, <span class="year">2011</span>.

</li><br>
<li id=Diankov10>
<span class="author">Rosen Diankov</span>, 
<span class="title">"Automated Construction of Robotic Manipulation Programs"</span>, 
PhD thesis, Carnegie Mellon University, August, <span class="year">2010</span>.

</li><br>
<li id=Dai17>
<span class="author">Hongkai Dai and Gregory Izatt and Russ Tedrake</span>, 
<span class="title">"Global inverse kinematics via mixed-integer convex optimization"</span>, 
<span class="publisher">International Symposium on Robotics Research</span>, <span class="year">2017</span>.
[&nbsp;<a href="http://groups.csail.mit.edu/robotics-center/public_papers/Dai17.pdf">link</a>&nbsp;]

</li><br>
<li id=Trutman22>
<span class="author">Pavel Trutman and Mohab Safey El Din and Didier Henrion and Tomas Pajdla</span>, 
<span class="title">"Globally optimal solution to inverse kinematics of 7DOF serial manipulator"</span>, 
<span class="publisher">IEEE Robotics and Automation Letters</span>, vol. 7, no. 3, pp. 6012--6019, <span class="year">2022</span>.

</li><br>
<li id=Ratliff09a>
<span class="author">Nathan Ratliff and Matthew Zucker and J. Andrew (Drew) Bagnell and Siddhartha Srinivasa</span>, 
<span class="title">"{CHOMP}: Gradient Optimization Techniques for Efficient Motion Planning"</span>, 
<span class="publisher">IEEE International Conference on Robotics and Automation (ICRA)</span> , May, <span class="year">2009</span>.

</li><br>
<li id=Kalakrishnan11a>
<span class="author">Mrinal Kalakrishnan and Sachin Chitta and Evangelos Theodorou and Peter Pastor and Stefan Schaal</span>, 
<span class="title">"{STOMP}: Stochastic trajectory optimization for motion planning"</span>, 
<span class="publisher">2011 IEEE international conference on robotics and automation</span> , pp. 4569--4574, <span class="year">2011</span>.

</li><br>
<li id=Toussaint17>
<span class="author">Marc Toussaint</span>, 
<span class="title">"A tutorial on Newton methods for constrained trajectory optimization and relations to SLAM, Gaussian Process smoothing, optimal control, and probabilistic inference"</span>, 
<span class="publisher">Geometric and numerical foundations of movements</span>, pp. 361--392, <span class="year">2017</span>.

</li><br>
<li id=Toussaint14>
<span class="author">Marc Toussaint</span>, 
<span class="title">"A Novel Augmented Lagrangian Approach for Inequalities and Convergent Any-Time Non-Central Updates"</span>, 
, <span class="year">2014</span>.

</li><br>
<li id=Geraerts04>
<span class="author">R. Geraerts and M. Overmars</span>, 
<span class="title">"A comparative study of probabilistic roadmap planners"</span>, 
<span class="publisher">Algorithmic Foundations of Robotics V</span>, pp. 43--58, <span class="year">2004</span>.

</li><br>
<li id=Karaman11>
<span class="author">S. Karaman and E. Frazzoli</span>, 
<span class="title">"Sampling-based Algorithms for Optimal Motion Planning"</span>, 
<span class="publisher">Int. Journal of Robotics Research</span>, vol. 30, pp. 846--894, June, <span class="year">2011</span>.

</li><br>
<li id=Deits14>
<span class="author">Robin L H Deits and Russ Tedrake</span>, 
<span class="title">"Computing Large Convex Regions of Obstacle-Free Space through Semidefinite Programming"</span>, 
<span class="publisher">Proceedings of the Eleventh International Workshop on the Algorithmic Foundations of Robotics (WAFR 2014)</span> , <span class="year">2014</span>.
[&nbsp;<a href="http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf">link</a>&nbsp;]

</li><br>
</ol>
</section><p/>
</div>

<table style="width:100%;" pdf="no"><tr style="width:100%">
  <td style="width:33%;text-align:left;"><a class="previous_chapter" href=mobile.html>Previous Chapter</a></td>
  <td style="width:33%;text-align:center;"><a href=index.html>Table of contents</a></td>
  <td style="width:33%;text-align:right;"><a class="next_chapter" href=force.html>Next Chapter</a></td>
</tr></table>

<div id="footer" pdf="no">
  <hr>
  <table style="width:100%;">
    <tr><td><a href="https://accessibility.mit.edu/">Accessibility</a></td><td style="text-align:right">&copy; Russ
      Tedrake, 2022</td></tr>
  </table>
</div>


</body>
</html>
